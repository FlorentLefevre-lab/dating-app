// schema.prisma - Version corrigée et nettoyée

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ================================
// ENUMS
// ================================

enum Gender {
  MALE
  FEMALE
  NON_BINARY
  OTHER
  PREFER_NOT_TO_SAY
  ALL
}

enum MaritalStatus {
  SINGLE
  DIVORCED
  WIDOWED
  SEPARATED
}

enum LookingFor {
  SERIOUS_RELATIONSHIP
  CASUAL
  FRIENDSHIP
  ADVENTURE
  MARRIAGE
  UNSURE
}

enum AccountStatus {
  ACTIVE
  SUSPENDED
  BANNED
  DELETED
  PENDING_VERIFICATION
}

enum AuthMethod {
  EMAIL_PASSWORD
  GOOGLE
  FACEBOOK
  APPLE
}

enum MessageStatus {
  SENT
  DELIVERED
  READ
  DELETED
}

// ================================
// ENUMS ADMIN
// ================================

enum UserRole {
  USER
  MODERATOR
  ADMIN
}

enum PhotoModerationStatus {
  PENDING
  APPROVED
  REJECTED
  FLAGGED
}

enum ReportStatus {
  PENDING
  UNDER_REVIEW
  RESOLVED
  DISMISSED
}

enum ReportCategory {
  INAPPROPRIATE_CONTENT
  HARASSMENT
  FAKE_PROFILE
  SPAM
  UNDERAGE
  SCAM
  OTHER
}

enum AdminActionType {
  USER_SUSPENDED
  USER_BANNED
  USER_UNBANNED
  USER_DELETED
  USER_WARNED
  PHOTO_APPROVED
  PHOTO_REJECTED
  REPORT_RESOLVED
  REPORT_DISMISSED
  ROLE_CHANGED
  SETTINGS_UPDATED
  CONTENT_REMOVED
}

// ================================
// MODÈLE USER PRINCIPAL
// ================================

model User {
  id             String    @id @default(cuid())
  email          String    @unique
  emailVerified  DateTime?
  hashedPassword String?
  image          String?

  // Informations de base
  name      String?
  age       Int?
  birthDate DateTime?
  bio       String?
  location  String?

  // Informations détaillées
  profession    String?
  gender        Gender?
  maritalStatus MaritalStatus?
  zodiacSign    String?
  dietType      String?
  religion      String?
  ethnicity     String?

  // Caracteristiques physiques
  height        Int?      // en cm
  weight        Int?      // en kg
  bodyType      String?   // Mince, Athletique, Normal, Quelques kilos en plus, etc.
  eyeColor      String?
  hairColor     String?

  // Style de vie
  smoking       String?   // Non-fumeur, Fumeur occasionnel, Fumeur
  drinking      String?   // Jamais, Occasionnellement, Regulierement
  drugs         String?   // Jamais, Occasionnellement, Sociales
  children      String?   // N'en a pas, En a, N'en veut pas, En veut
  pets          String?   // Aucun, Chien, Chat, Autres
  education     String?   // Niveau d'etudes
  languages     String[]  // Langues parlees

  // Champs géographiques
  department String?
  postcode   String?
  region     String?

  // Statut du compte et suspension
  accountStatus    AccountStatus @default(ACTIVE)
  suspensionReason String?
  suspendedAt      DateTime?
  suspendedUntil   DateTime?

  // Statut en ligne
  lastSeen DateTime?
  isOnline Boolean   @default(false)

  // Abonnement Premium
  isPremium        Boolean   @default(false)
  premiumExpiresAt DateTime?

  // Donateur (supporter)
  hasDonated       Boolean   @default(false)
  firstDonationAt  DateTime?

  // Rôle utilisateur (admin)
  role UserRole @default(USER)

  // Onboarding (une seule fois après inscription)
  onboardingCompletedAt DateTime?

  // Données existantes
  interests         String[]
  primaryAuthMethod AuthMethod @default(EMAIL_PASSWORD)
  createdAt         DateTime   @default(now())
  updatedAt         DateTime   @updatedAt

  // Relations de base
  accounts             Account[]
  sessions             Session[]
  photos               Photo[]
  preferences          UserPreferences?
  notificationSettings NotificationSettings?
  notifications        Notification[]

  // Relations de likes/matches  
  likesGiven    Like[] @relation("UserLikesGiven")
  likesReceived Like[] @relation("UserLikesReceived")

  // Relations de dislikes
  dislikesGiven    Dislike[] @relation("UserDislikesGiven")
  dislikesReceived Dislike[] @relation("UserDislikesReceived")

  // Relations de blocage
  blocksGiven    Block[] @relation("UserBlocksGiven")
  blocksReceived Block[] @relation("UserBlocksReceived")

  // Relations de vues de profil
  profileViewsGiven    ProfileView[] @relation("UserViewsGiven")
  profileViewsReceived ProfileView[] @relation("UserViewsReceived")

  // Relations de matchs
  matchesAsUser1 Match[] @relation("UserMatches1")
  matchesAsUser2 Match[] @relation("UserMatches2")

  // Stats dénormalisées
  stats UserStats?

  // Relations Admin
  photosModerated   Photo[]    @relation("PhotoModerator")
  reportsSubmitted  Report[]   @relation("ReportSubmitter")
  reportsReceived   Report[]   @relation("ReportTarget")
  reportsResolved   Report[]   @relation("ReportResolver")
  adminActions      AdminLog[] @relation("AdminActor")
  actionsReceived   AdminLog[] @relation("AdminActionTarget")

  // Relations Tickets
  tickets           Ticket[]        @relation("UserTickets")
  assignedTickets   Ticket[]        @relation("AssignedTickets")
  resolvedTickets   Ticket[]        @relation("ResolvedTickets")
  ticketMessages    TicketMessage[] @relation("TicketMessages")

  // Relations Donations
  donations         Donation[]

  @@map("users")
}

// ================================
// MODÈLES NEXTAUTH
// ================================

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@map("accounts")
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
  @@map("verification_tokens")
}

model Photo {
  id        String   @id @default(cuid())
  userId    String
  url       String
  isPrimary Boolean  @default(false)
  createdAt DateTime @default(now())

  // Champs de modération
  moderationStatus PhotoModerationStatus @default(PENDING)
  moderatedAt      DateTime?
  moderatedBy      String?
  moderationNote   String?
  nsfwScore        Float?
  autoFlagged      Boolean               @default(false)

  user      User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  moderator User? @relation("PhotoModerator", fields: [moderatedBy], references: [id])

  @@index([moderationStatus])
  @@index([createdAt])
  @@map("photos")
}

model UserPreferences {
  id          String   @id @default(cuid())
  userId      String   @unique
  minAge      Int      @default(18)
  maxAge      Int      @default(35)
  maxDistance Int      @default(50)
  gender      Gender?
  lookingFor  String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("user_preferences")
}

model NotificationSettings {
  id                   String   @id @default(cuid())
  userId               String   @unique
  messageNotifications Boolean  @default(true)
  likeNotifications    Boolean  @default(true)
  matchNotifications   Boolean  @default(true)
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("notification_settings")
}

model Notification {
  id        String           @id @default(cuid())
  userId    String
  type      NotificationType
  title     String
  message   String
  read      Boolean          @default(false)
  data      Json?
  createdAt DateTime         @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([read])
  @@index([createdAt])
  @@map("notifications")
}

enum NotificationType {
  SYSTEM
  MATCH
  MESSAGE
  LIKE
  WARNING
  SUSPENSION
}

model Like {
  id         String   @id @default(cuid())
  senderId   String
  receiverId String
  createdAt  DateTime @default(now())

  sender   User @relation("UserLikesGiven", fields: [senderId], references: [id], onDelete: Cascade)
  receiver User @relation("UserLikesReceived", fields: [receiverId], references: [id], onDelete: Cascade)

  @@unique([senderId, receiverId])
  @@index([senderId])
  @@index([receiverId])
  @@map("likes")
}

model Dislike {
  id         String   @id @default(cuid())
  senderId   String
  receiverId String
  createdAt  DateTime @default(now())

  sender   User @relation("UserDislikesGiven", fields: [senderId], references: [id], onDelete: Cascade)
  receiver User @relation("UserDislikesReceived", fields: [receiverId], references: [id], onDelete: Cascade)

  @@unique([senderId, receiverId])
  @@index([senderId])
  @@index([receiverId])
  @@map("dislikes")
}

model Block {
  id        String   @id @default(cuid())
  blockerId String
  blockedId String
  reason    String?
  createdAt DateTime @default(now())

  blocker User @relation("UserBlocksGiven", fields: [blockerId], references: [id], onDelete: Cascade)
  blocked User @relation("UserBlocksReceived", fields: [blockedId], references: [id], onDelete: Cascade)

  @@unique([blockerId, blockedId])
  @@index([blockerId])
  @@index([blockedId])
  @@map("blocks")
}

model ProfileView {
  id        String   @id @default(cuid())
  viewerId  String
  viewedId  String
  createdAt DateTime @default(now())

  viewer User @relation("UserViewsGiven", fields: [viewerId], references: [id], onDelete: Cascade)
  viewed User @relation("UserViewsReceived", fields: [viewedId], references: [id], onDelete: Cascade)

  @@unique([viewerId, viewedId])
  @@index([viewerId])
  @@index([viewedId])
  @@map("profile_views")
}

// ================================
// MODÈLE MATCH
// ================================

enum MatchStatus {
  ACTIVE
  UNMATCHED
  BLOCKED
}

model Match {
  id        String      @id @default(cuid())
  user1Id   String
  user2Id   String
  status    MatchStatus @default(ACTIVE)
  createdAt DateTime    @default(now())
  updatedAt DateTime    @updatedAt

  // Relations - user1Id est toujours < user2Id pour éviter les doublons
  user1 User @relation("UserMatches1", fields: [user1Id], references: [id], onDelete: Cascade)
  user2 User @relation("UserMatches2", fields: [user2Id], references: [id], onDelete: Cascade)

  @@unique([user1Id, user2Id])
  @@index([user1Id])
  @@index([user2Id])
  @@index([status])
  @@map("matches")
}

// ================================
// MODÈLE USER STATS (dénormalisé pour performance)
// ================================

model UserStats {
  id        String   @id @default(cuid())
  userId    String   @unique

  // Stats totales
  totalProfileViews  Int @default(0)
  totalLikesReceived Int @default(0)
  totalLikesSent     Int @default(0)
  totalMatches       Int @default(0)
  totalMessages      Int @default(0)

  // Stats quotidiennes (réinitialisées chaque jour)
  dailyProfileViews  Int @default(0)
  dailyLikesReceived Int @default(0)
  dailyLikesSent     Int @default(0)
  dailyMatches       Int @default(0)

  // Date de dernière mise à jour des stats quotidiennes
  lastDailyReset DateTime @default(now())

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relation
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("user_stats")
}

// ================================
// MODÈLES ADMIN - SIGNALEMENTS
// ================================

model Report {
  id           String         @id @default(cuid())
  reporterId   String
  targetUserId String
  category     ReportCategory
  description  String?
  status       ReportStatus   @default(PENDING)
  priority     Int            @default(0) // 0=low, 1=medium, 2=high

  // Evidence
  evidenceUrls String[]
  photoId      String?

  // Resolution
  resolvedAt DateTime?
  resolvedBy String?
  resolution String?

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  reporter   User  @relation("ReportSubmitter", fields: [reporterId], references: [id], onDelete: Cascade)
  targetUser User  @relation("ReportTarget", fields: [targetUserId], references: [id], onDelete: Cascade)
  resolver   User? @relation("ReportResolver", fields: [resolvedBy], references: [id])

  @@index([status])
  @@index([category])
  @@index([targetUserId])
  @@index([createdAt])
  @@map("reports")
}

// ================================
// MODÈLES ADMIN - LOGS D'AUDIT
// ================================

model AdminLog {
  id           String          @id @default(cuid())
  adminId      String
  targetUserId String?
  actionType   AdminActionType
  details      Json?
  ipAddress    String?
  userAgent    String?
  createdAt    DateTime        @default(now())

  admin      User  @relation("AdminActor", fields: [adminId], references: [id], onDelete: Cascade)
  targetUser User? @relation("AdminActionTarget", fields: [targetUserId], references: [id])

  @@index([adminId])
  @@index([targetUserId])
  @@index([actionType])
  @@index([createdAt])
  @@map("admin_logs")
}

// ================================
// MODÈLES ADMIN - STATS GLOBALES (cache)
// ================================

model GlobalStats {
  id String @id @default("singleton")

  // User stats
  totalUsers       Int @default(0)
  activeUsersToday Int @default(0)
  activeUsersWeek  Int @default(0)
  newUsersToday    Int @default(0)
  newUsersWeek     Int @default(0)
  newUsersMonth    Int @default(0)

  // Engagement stats
  totalMatches Int @default(0)
  matchesToday Int @default(0)
  matchesWeek  Int @default(0)
  totalLikes   Int @default(0)
  likesToday   Int @default(0)

  // Moderation stats
  pendingPhotoReviews Int @default(0)
  pendingReports      Int @default(0)

  // Retention
  day1Retention  Float @default(0)
  day7Retention  Float @default(0)
  day30Retention Float @default(0)

  lastCalculated DateTime @default(now())

  @@map("global_stats")
}

// ================================
// MODÈLES ADMIN - PARAMÈTRES APPLICATION
// ================================

model AppSettings {
  id String @id @default("singleton")

  // === MODÉRATION ===
  // Seuil de score NSFW pour auto-flag (0.0 à 1.0)
  nsfwThreshold Float @default(0.7)
  // Nombre de signalements avant auto-suspension
  reportsBeforeAutoSuspend Int @default(5)
  // Durées de suspension par défaut (en jours, -1 = permanent)
  suspensionDurations Int[] @default([1, 7, 30, -1])
  // Auto-approuver les photos (désactive la modération manuelle)
  autoApprovePhotos Boolean @default(false)

  // === LIMITES UTILISATEURS ===
  // Likes par jour (gratuit)
  dailyLikesLimit Int @default(50)
  // Likes par jour (premium)
  dailyLikesLimitPremium Int @default(999)
  // Super likes par jour (gratuit)
  dailySuperLikesLimit Int @default(1)
  // Super likes par jour (premium)
  dailySuperLikesLimitPremium Int @default(5)
  // Nombre max de photos par profil
  maxPhotosPerUser Int @default(6)
  // Messages par jour pour nouveaux comptes (< 7 jours)
  dailyMessagesLimitNewUsers Int @default(20)
  // Rewinds par jour (gratuit)
  dailyRewindsLimit Int @default(0)
  // Rewinds par jour (premium)
  dailyRewindsLimitPremium Int @default(5)

  // === INSCRIPTION ===
  // Âge minimum
  minAge Int @default(18)
  // Âge maximum
  maxAge Int @default(99)
  // Vérification email obligatoire
  emailVerificationRequired Boolean @default(true)
  // Inscriptions ouvertes
  registrationOpen Boolean @default(true)
  // Régions autorisées (vide = toutes)
  allowedRegions String[] @default([])

  // === MATCHING ===
  // Distance max par défaut (km)
  defaultMaxDistance Int @default(100)
  // Distance max autorisée (km)
  maxDistanceLimit Int @default(500)
  // Écart d'âge par défaut
  defaultAgeRange Int @default(10)

  // === FEATURE FLAGS ===
  // Mode maintenance
  maintenanceMode Boolean @default(false)
  // Message de maintenance
  maintenanceMessage String @default("L'application est en maintenance. Veuillez réessayer plus tard.")
  // Fonctionnalité premium active
  premiumEnabled Boolean @default(true)
  // Vidéo-chat actif
  videoChatEnabled Boolean @default(false)
  // Stories actives
  storiesEnabled Boolean @default(false)
  // Boost de profil actif
  boostEnabled Boolean @default(true)

  // === MESSAGES SYSTÈME ===
  // Annonce globale (vide = pas d'annonce)
  globalAnnouncement String @default("")
  // Type d'annonce (info, warning, success, error)
  announcementType String @default("info")
  // Message de bienvenue
  welcomeMessage String @default("Bienvenue sur FlowDating ! Complétez votre profil pour commencer.")
  // Conditions d'utilisation (URL)
  termsUrl String @default("/terms")
  // Politique de confidentialité (URL)
  privacyUrl String @default("/privacy")

  // === SÉCURITÉ ===
  // Tentatives de connexion max avant blocage
  maxLoginAttempts Int @default(5)
  // Durée de blocage après échecs (minutes)
  loginBlockDuration Int @default(15)
  // Session expiration (heures)
  sessionExpirationHours Int @default(168)
  // Forcer HTTPS
  forceHttps Boolean @default(true)

  // === MÉTADONNÉES ===
  updatedAt DateTime @updatedAt
  updatedBy String?

  @@map("app_settings")
}

// ================================
// MODÈLES TICKETS / SUPPORT
// ================================

enum TicketStatus {
  OPEN
  IN_PROGRESS
  WAITING_USER
  RESOLVED
  CLOSED
}

enum TicketPriority {
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

enum TicketCategory {
  BUG
  FEATURE_REQUEST
  ACCOUNT_ISSUE
  PAYMENT
  HARASSMENT
  TECHNICAL
  OTHER
}

model Ticket {
  id          String         @id @default(cuid())
  userId      String

  // Contenu du ticket
  subject     String
  description String
  category    TicketCategory
  priority    TicketPriority @default(MEDIUM)
  status      TicketStatus   @default(OPEN)

  // Informations techniques (auto-collectées)
  userAgent   String?
  appVersion  String?
  screenSize  String?
  currentUrl  String?

  // Pièces jointes (URLs des screenshots)
  attachments String[]

  // Gestion admin
  assignedTo  String?
  resolvedAt  DateTime?
  resolvedBy  String?
  resolution  String?

  // Timestamps
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  user        User     @relation("UserTickets", fields: [userId], references: [id], onDelete: Cascade)
  assignee    User?    @relation("AssignedTickets", fields: [assignedTo], references: [id])
  resolver    User?    @relation("ResolvedTickets", fields: [resolvedBy], references: [id])
  messages    TicketMessage[]

  @@index([userId])
  @@index([status])
  @@index([priority])
  @@index([category])
  @@index([assignedTo])
  @@index([createdAt])
  @@map("tickets")
}

model TicketMessage {
  id        String   @id @default(cuid())
  ticketId  String
  userId    String
  message   String
  isAdmin   Boolean  @default(false)
  createdAt DateTime @default(now())

  ticket    Ticket   @relation(fields: [ticketId], references: [id], onDelete: Cascade)
  user      User     @relation("TicketMessages", fields: [userId], references: [id], onDelete: Cascade)

  @@index([ticketId])
  @@index([createdAt])
  @@map("ticket_messages")
}

// ================================
// MODÈLE DONATIONS
// ================================

enum DonationStatus {
  PENDING
  COMPLETED
  FAILED
  REFUNDED
}

enum DonationProvider {
  STRIPE
  PAYPAL
  LIGHTNING
}

model Donation {
  id              String           @id @default(cuid())

  // Donateur (optionnel si anonyme)
  userId          String?
  email           String?
  name            String?

  // Montant
  amount          Float            // Montant en euros
  currency        String           @default("EUR")

  // Provider et transaction
  provider        DonationProvider
  providerOrderId String?          // ID Stripe/PayPal
  status          DonationStatus   @default(PENDING)

  // Message du donateur
  message         String?

  // Métadonnées
  metadata        Json?

  // Timestamps
  createdAt       DateTime         @default(now())
  completedAt     DateTime?

  // Relation optionnelle avec User
  user            User?            @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@index([userId])
  @@index([status])
  @@index([provider])
  @@index([createdAt])
  @@map("donations")
}
